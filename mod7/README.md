# Алгоритмы

Конкретная последовательность действий для решения определённой задачи называется алгоритмом решения задачи. Для одной и той же задачи может быть несколько разных алгоритмов. Какой из них выбрать — напрямую зависит от условий задачи.

Алгоритм «едем домой на лифте»:
1. Нажать на кнопку вызова лифта, дождаться, пока он приедет и откроет двери.
2. Зайти в кабину лифта, нажать на кнопку девятого этажа. Подождать, пока двери закроются, лифт поднимется, двери откроются.
3. Если этаж не твой — выполняй алгоритм с самого начала.
4. Открыть дверь квартиры, зайти.


При подъёме по лестнице алгоритм будет примерно такой:
1. Поднимись на один этаж.
2. Проверь, на каком ты этаже.
 1. Если этаж не твой — выполняй алгоритм с самого начала.
 2. Если этаж твой — открой дверь квартиры, входи.



# Хранение данных и эффективность алгоритма
Список и множество — изменяемые коллекции, а кортеж — неизменяемый. Список и кортеж сохраняют порядок элементов и предоставляют доступ к элементам по индексам, а множество — это неупорядоченная коллекция. 

У разных типов коллекций — разные свойства и, очевидно, разные области применения. Ведь если бы существовала наилучшая и универсальная разновидность коллекции, то создатели языка оставили бы только её. Но нет, в язык встроено несколько коллекций с разными свойствами.
Чтобы сделать осознанный выбор, нужно понимать, как эти коллекции устроены «под капотом», и заранее оценить, как коллекции будут применяться в программе:
1. Насколько часто коллекция будет изменяться?
2. Как часто будет происходить обращение к элементам коллекции?
3. Обращение будет только к первому и последнему элементу — или ко всем?
4. Насколько часто будет проверяться наличие конкретного элемента в коллекции?

При решении любой задачи программист самостоятельно определяет, как хранить и обрабатывать данные. Для разных ситуаций понадобятся разные подходы.
Например, если в библиотеке книги на полках расставлены по алфавиту, библиотекарь и даже обычный посетитель быстро найдут нужную книгу.
Но за всё приходится платить. Когда в библиотеку поступит собрание сочинений Чехова в восемнадцати томах, придётся освобождать для него место в шкафу под буквой «Ч» и переставлять книги Чжан Чао, Чуковского и вообще всех, кто по алфавиту стоит после Чехова. Работа немалая, зато после этого искать книги будет удобно.

Получается, при такой системе хранения книг на поиск расходуется мало ресурсов, а добавление новых книг требует значительных затрат.
На книжных полках в квартире, как правило, ситуация иная: книги могут быть расставлены без системы, и поиск нужной книги может занять значительное время.

Зато найти место для новой книги можно легко и быстро: ставь на любое свободное место — и готово.

При такой системе хранения поиск — затратное дело, зато добавление новых книг в коллекцию не составляет труда.

Даже на примере хранения книг видно, что «единственно верного» решения нет. Если книги чаще ищут, чем добавляют, то есть смысл отсортировать книги по алфавиту, пусть даже это затруднит добавление новых томов. Если же новые книги появляются чаще, чем их ищут на полках, лучше пожертвовать удобством поиска и ставить книги без системы, на любое свободное место: так будет быстрее.

Мы балансируем, выбирая между скоростью выполнения алгоритма и ресурсами, которые необходимы для его выполнения. Можно написать быстро работающий алгоритм, но он съест много оперативной памяти. Можно обойтись минимальным количеством оперативки, но программа будет работать медленно.


# Массивы
Алгоритмы — универсальная дисциплина для разных языков программирования, и в этой дисциплине применяют терминологию, не привязанную ни к одному из языков. Так, например, в разговоре о наборах данных применяют обобщённый термин массив

Под «классическим», или «обычным», массивом мы будем понимать совокупность элементов одного типа (например, только целые числа или только строки), к каждому из которых можно обращаться по индексу.

Например, в языке Python наибольшее сходство с массивом имеет список, list. Но есть важное отличие: список в Python может одновременно хранить вперемешку и числа, и строки, и другие коллекции, а классический массив может хранить только однородные и простейшие, несоставные элементы.


# Эффективный ввод и вывод в Python
При решении алгоритмических задач приходится учитывать многие детали и требования, которые могут повлиять на эффективность программы.

Требования могут быть разного рода, например: требования к скорости вычислений. Алгоритмы, к которым предъявляются требования по быстродействию, называют CPU-bound. К программам могут предъявляться и требования по потребляемому объёму памяти: это алгоритмы memory-bound. 

Ещё один важный аспект работы программ — это скорость ввода-вывода. Алгоритм может отработать быстро, но потратить бо́льшую часть времени на ожидание входных данных или на вывод результата вычислений. Этот тип ограничений называют I/O-bound. I/O — это input/output (англ. «ввод/вывод»).

И в алгоритмах CPU-bound, и в I/O-bound ограничивающий фактор — это время выполнения программы. Но в первом случае время тратит процессор, а во втором случае время уходит на работу оперативной памяти, жёсткого диска и операционной системы.

Проверить скорость работы программы
```bash 
$ time yes | python check.py
```

Предположим, что одна из задач требует считать из stdin пять строк по пять элементов. Таким образом, в stdin — шесть строк: число, определяющее количество массивов, и сами массивы.

```bash
5
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
```

```bash
# Считываем первую строку ввода и приводим её к числу.
# Это количество строк в дальнейшем вводе.
elements_count = int(input())

# Формируем пустой список с нужным количеством элементов,
# чтобы не реаллоцировать массив при заполнении.
data = [None] * elements_count

# Для каждой строки исходных данных.
for index in range(elements_count):
    # Добавляем её на определённую позицию в массиве.
    data[index] = input()

# Выводим на печать.
print(data) 
```


# Эффективный вывод
Вывод данных тоже требует участия операционной системы, и это участие нужно минимизировать. Если необходимо напечатать несколько отдельных строк, будет целесообразно объединить их в одну, разделённую символами перевода строки \n, и лишь затем отправить на печать. Это позволит уменьшить количество обращений к операционной системе.

```bash
print('Раз, два, три, четыре, пять')
print('Вышел')
print('Python')
print('Погулять')
```

```bash
print('Раз, два, три, четыре, пять\nВышел\nPython\nПогулять\n') 
```

# Эффективный ввод и вывод на практике
Объединим эффективный ввод и вывод в одном примере. Предположим, что задача предполагает такие исходные данные:
```bash
3
5 6
7 8
9 10 

# В первой строке указано количество строк с данными. В каждой строке — пара чисел, которые надо сложить. Результат надо вывести в таком виде:
11
15
19 
```
```bash
import sys


def main():
    # Прочитали первую строку, в которой указано количество строк,
    # преобразовали в число:
    num_lines = int(sys.stdin.readline().rstrip())  
    output_numbers = [None] * num_lines
    # Читаем следующие строки ввода:
    for i in range(num_lines):
        # Считали строку и удалили символы перевода строки.
        line = sys.stdin.readline().rstrip()
        # Разделили строку по пробельному символу,        
        # присвоили значения из строки переменным first и second соответственно.
        first, second = line.split()  
        # Преобразовали строки в целые числа.
        first = int(first)  
        second = int(second)
        # Получили сумму.
        result = first + second  
        # Записали в массив ответов текущий результат как строку.
        output_numbers[i] = str(result)
    # В конце вывели все полученные ответы за один раз.
    print('\n'.join(output_numbers)) 


if __name__ == '__main__':
    main() 
```