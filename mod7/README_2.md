# Линейный поиск
Задача «найти элемент в массиве» довольно распространена, но на практике за такой формулировкой могут скрываться две различные цели:
1. Проверить, есть ли в массиве заданный элемент.
2. Определить индекс (порядковый номер) заданного элемента в массиве. А если точнее — определить индекс первого найденного в массиве элемента с нужным значением: это называют «первое вхождение элемента». Ведь в некоторых случаях одно и то же значение может встречаться в массиве несколько раз.


Допустим у нас есть лотерейный билет. организация проводившая лотерею опубликовала выйгрышные номера в виде списка.

Результаты лотереи печатаются вразнобой, номера в таблице идут не в порядке возрастания, а как попало.

Перед владельцем лотерейного билета стоит сложная задача: найти номер своего билета в списке — и при этом владелец не знает наверняка, есть ли его номер в списке выигрышей. При поиске царит нешуточный накал страстей — ведь до самого последнего момента можно надеяться, что номер купленного билета не нашёлся в таблице не потому, что его там нет, а потому, что он напечатан ближе к концу! 

Очевидно, что чем больше список, тем больше времени нужно затратить на поиск нужного номера. Особых вариантов для решения этой задачи нет — можно просматривать таблицу от начала до конца, можно от конца к началу, но затраченное время и усилия будут примерно одинаковыми. Да, может повезти, и нужный номер будет стоять первым. Но в худшем случае (например, если номера вообще нет в списке или он стоит последним) придётся просмотреть все записи.

```bash
wins = [7495938, 1223125, 2128437, 4567890, 2128500, 2741001, 9314543, 4567687]
my_ticket = 2128506


def check_element_in_unordered_list(desired_element, unordered_list):
    """Проверяет наличие заданного элемента в неотсортированном списке."""
    # Итерируемся по списку.
    for item in unordered_list:
        # Каждый элемент сверяем с искомым.
        if item == desired_element:
            # Если элемент найден, то возвращаем значение True.
            return True
    # Если цикл прошёл, а элемент не найден, возвращаем False.
    return False


# Если функция вернула True...
if check_element_in_unordered_list(my_ticket, wins):
    # ...печатаем сообщение:
    print(f'Элемент {my_ticket} найден в списке!')
else:
    # Если функция вернула False - тоже сообщаем об этом.
    print(f'Элемент {my_ticket} не найден в списке.') 
```

Чтобы определить, есть ли искомое значение в списке, можно применить оператор in, проверяющий вхождение элемента в коллекцию. Выходит, можно одним выражением определить, есть ли нужный номер билета в списке: desired_element in unordered_list.

Однако «под капотом» Python выполнит примерно те же операции, что и в приведённом коде, а значит, алгоритмически никакого выигрыша не будет: код станет короче, но на его выполнение потребуется примерно столько же ресурсов.


# Функция enumerate()
Расширенный вариант той же задачи — отыскать элемент в массиве и узнать его индекс. Решить её поможет встроенная функция enumerate(). Она получает на вход коллекцию и возвращает итерируемый объект enumerate, который может быть представлен как коллекция кортежей, где каждый кортеж состоит из двух элементов: индекса элемента и его значения. По этому объекту можно проитерироваться только один раз.

```bash
# Исходный список:
wins = [7495938, 1223125, 2128437, 4567890, 2128500, 2741001, 9314543, 4567687]
# Применяем функцию enumerate:
indexed_nums = enumerate(wins)
# Распечатаем результат:
print('Печатаем объект:', indexed_nums)
# Это указание на место объекта в памяти.

# По объекту indexed_nums можно проитерироваться (перебрать его элементы в цикле):
print('Итерируемся по index_num:')
for index_num in indexed_nums:
    # Распечатаем содержимое каждого элемента объекта.
    print(index_num)

# На печать будет выведен набор кортежей, 
# в каждом кортеже - индекс элемента и его значение.

# Повторная попытка ничего не выведет: 
# проитерироваться по объекту enumerate можно только один раз.
print('Второй раз итерируемся по index_num:')
for index_num in indexed_nums:
    print(index_num)
# Пусто!

# Создаём объект enumerate заново.
indexed_nums = enumerate(wins)

# Объект enumerate можно преобразовать в список:
print('Преобразовали enumerate в список:', list(indexed_nums))
# Получим список кортежей.

# Если попробовать повторно распечатать список, он будет пустым:
# в момент преобразования объекта enumerate в список
# "под капотом" тоже происходит итерация по объекту.
print('Повторно печатаем список, полученный из enumerate:', list(indexed_nums))
# Пустой список!
```


```bash
def find_element_index_in_unordered_list(desired_element, unordered_list):
    """
    Находит индекс первого вхождения искомого элемента 
    в неотсортированном списке.
    """
    # Применяем к списку функцию enumerate(), итерируемся
    # по полученному объекту enumerate и распаковываем его кортежи:
    # в переменную index сохраняем индекс элемента, в item - его значение.
    for index, item in enumerate(unordered_list):
        # Если значение текущего элемента равно искомому...
        if item == desired_element:
            # ...возвращаем его индекс:
            return index
    # Если цикл пройден, но нужное значение не найдено,
    # то возвращаем None. 
    # Явно возвращать None не обязательно, эту строку можно вообще не писать:
    # если в функции нет оператора return, она возвращает None.
    return None


wins = [7495938, 1223125, 2128437, 4567890, 2128500, 2741001, 9314543, 4567687]
my_ticket = 2128506
result = find_element_index_in_unordered_list(my_ticket, wins)
if result is not None:
    print(f'Индекс элемента {my_ticket} в массиве: {result}')
else:
    print(f'Элемент {my_ticket} не найден в массиве.')
```

Какой код ни применяй — для поиска значения в несортированном массиве тебе придётся перебирать все элементы по одному до тех пор, пока не найдёшь нужный.

Эффективность алгоритмов принято определять для худших случаев. 

Если массив данных не отсортирован, то в худшем случае найти элемент в массиве или убедиться в его отсутствии можно только путём полного перебора массива.

# Линейный поиск
Последовательный перебор всех элементов называется «линейный проход по массиву», а поиск, выполняемый путём линейного прохода, — «линейный поиск».
При линейном поиске время выполнения программы напрямую зависит от длины массива, по которому проводится поиск. Чем больше элементов в массиве, тем больше операций в худшем случае надо выполнить и тем больше будет время работы алгоритма.


Поиск в отсортированном массиве даёт очевидную выгоду по сравнению с несортированным: даже если нужного значения нет в массиве, нет нужды перебирать весь массив до конца, нужно лишь проверить, что его нет в определённом диапазоне.


```bash
def check_element_in_list(desired_element, ordered_list):
    """Проверяет наличие искомого элемента в отсортированном списке."""
    for item in ordered_list:
        if item < desired_element:
            continue
        elif item > desired_element:
            return f'Элемент {desired_element} не найден в массиве.'
        if item == desired_element:
            return f'Элемент {desired_element} найден в массиве!'
    return f'Элемент {desired_element} не найден в массиве.'


# Вызываем функцию с тестовыми данными.
# Первый аргумент - целое число.
# Второй аргумент - отсортированный по возрастанию список целых чисел.
result = check_element_in_list(4, [1, 3, 5, 7, 10])
# Распечатываем результат.
print(result)
```