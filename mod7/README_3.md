# Биннарный поиск

Алгоритм бинарного поиска предназначен для обнаружения целевого значения в отсортированном массиве. В процессе поиска целевое значение сравнивается с элементом в середине массива. Если значения не равны, половина, в которой искомый элемент не может находиться, больше не рассматривается, и поиск продолжается во второй половине: снова берётся средний элемент и сравнивается с целевым значением. Операция повторяется до тех пор, пока целевое значение не будет найдено. Если в конце поиска оставшаяся половина оказывается пустой, значит, цель отсутствует в массиве.

При бинарном поиске мы за один шаг отбрасываем сразу половину всех неправильных ответов и работаем с оставшейся половиной массива.

Списком, в котором числа идут не последовательно, а с пропусками или дубликатами: каждый раз надо брать элемент, который стоит в середине той части массива, с которой мы работаем. Для этого есть индексы элементов. В приведённом списке у первого элемента индекс 0, у последнего — индекс 12, значит, у среднего — индекс 6
```bash
marsium = [1, 2, 5, 8, 12, 12, 13, 20, 22, 23, 24, 30, 32]
# Индексы: 0  1  2  3   4   5   6   7   8   9  10  11  12 
```

А дальше — дело техники: сравниваем искомое значение со средним элементом, берём нужную половину массива, там опять ищем индекс среднего элемента… и так по кругу до победного конца.

Поищем в списке marsium значение 22. Берём средний элемент в массиве: это элемент с индексом 6, его значение — 13. Сравниваем найденное в массиве значение с искомым: искомое больше. Значит, поиск надо продолжить во второй половине массива, среди элементов с индексами от 7 до 12.

Следующий шаг — вычислить индекс среднего элемента в правой половине массива. Первый индекс в этой части массива (левый, left) — 7, последний индекс (правый, right) — 12. Средний элемент (назовём его mid, от middle, «средний») вычисляется так: mid = (left + right) // 2.

Бинарному поиску не помешали дубликаты и пропуски в ряду чисел. Всё работает, главное — чтобы массив был отсортирован. Единственная особенность: если значения дублируются, то при бинарном поиске мы не обязательно обнаружим именно первое вхождение элемента. Найдётся один из дубликатов, но какой — не известно.

Это алгоритм назвали «бинарным поиском» потому, что на каждом шаге отсортированный массив данных делится пополам. Иногда его называют «двоичный поиск», а иногда просто «метод деления пополам».

Теперь посмотрим, как бинарный поиск выглядит в коде. Для эксперимента отыщем индекс выигрышного лотерейного билета в отсортированном списке:

```bash
wins = [1223125, 2128437, 2128500, 2741001, 4567687, 4567890, 7495938, 9314543]
my_ticket = 4567890


def find_element(sorted_numbers, element):
    """Находит индекс element в отсортированном списке sorted_numbers."""
    # Левая граница (левый индекс) рассматриваемого набора элементов. 
    # В начале работы она равна индексу первого элемента в списке - нулю.
    left = 0
    # Правая граница (правый индекс) рассматриваемого набора элементов. 
    # В начале работы она равна индексу последнего элемента в списке.
    right = len(sorted_numbers) - 1
    # Пока левая граница меньше правой или равна ей:
    while left <= right:
        # Находим в наборе элементов индекс среднего элемента.
        mid = (left + right) // 2
        # Если элемент с этим индексом равен искомому, возвращаем его индекс.
        if sorted_numbers[mid] == element:
            return mid
        # Если средний элемент меньше искомого...
        if sorted_numbers[mid] < element:
            # ...то изменяем левую границу поиска:
            left = mid + 1
        # Если средний элемент больше искомого...
        else:
            # ...то изменяем правую границу поиска:
            right = mid - 1
    # Если левая граница оказалась больше правой, 
    # значит, элемент не найден. Возвращаем None.
    return None


print(find_element(wins, my_ticket))
```

Бинарный поиск в массиве строк

Если массив содержит не числа, а строки, бинарный поиск сработает точно так же. Строки можно отсортировать «по возрастанию» (по алфавиту) и сравнивать операторами «больше», «меньше» и «равно». Для бинарного поиска этого вполне достаточно


Скорость работы бинарного поиска
Поиск в массиве из ста элементов в лучшем случае потребует лишь одного шага — если искомый элемент окажется точно в середине массива. В худшем случае потребуется семь шагов: игра в числа как раз показала поиск по «худшему», самому длинному, сценарию.

При обработке такого же массива алгоритмом линейного поиска для худшего случая потребуется 100 операций.

А за сколько шагов будет найден элемент в массиве из 500 элементов? А если элементов 1000? Если найти закономерность, то можно предсказать, насколько быстро будет работать алгоритм при увеличении объёма обрабатываемых данных.

С линейным поиском всё понятно: сколько элементов — столько и операций (для худшего случая).

Поищем закономерность для бинарного поиска. Для этого «развернём» алгоритм в обратную сторону: начнём с одного «найденного» элемента и будем удваивать объём массива, отсчитывая «шаги». За семь шагов-удвоений получаем число 128: 2 → 4 → 8 → 16 → 32 → 64 → 128. Получается, что бинарный поиск по массиву из 128 элементов тоже потребует не более семи шагов.

Числа в этой последовательности — это степени числа 2: 

Исходя из длины массива можно вычислить максимальное число операций, которое потребуется для бинарного поиска в этом массиве. Количество операций — целое число, поэтому, например, для поиска в массивах с длиной от 5 до 8 потребуется 3 шага. а в массивах с количеством элементов от 65 до 128 бинарному поиску понадобится не более 7 операций.


# Логарифмическая зависимость времени от длины массива
Чтобы определить количество операций, необходимых при бинарном поиске в массиве длиной n, надо узнать, в какую степень нужно возвести двойку, чтобы получить n или ближайшее к n число, большее, чем n. 

# Сравнение бинарного и линейного поиска
Сравним, как изменяется время работы бинарного и линейного поиска в зависимости от размера массива. 

Время работы линейного поиска зависит от размеров массива линейно: если массив увеличивается на один элемент, то и алгоритму придётся выполнить одну дополнительную операцию. 

Время работы бинарного поиска зависит от размеров массива логарифмически: увеличение длины обрабатываемого массива совсем не обязательно приводит к увеличению числа операций.

Линейный поиск медленнее бинарного, но не стоит списывать его со счетов. Например, чтобы один раз найти элемент в неотсортированном массиве, проще перебрать весь массив, чем отсортировать его и применить бинарный поиск. Сортировка — это не «бесплатная» операция, она тоже требует ресурсов и времени!

Если же в одном и том же массиве приходится часто искать нужные элементы, есть смысл сначала отсортировать массив, а потом применять к нему алгоритм бинарного поиска. Для разных задач оптимальные алгоритмы будут разными, и сравнение скорости алгоритмов поможет выбрать лучшее решение.