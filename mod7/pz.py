'''
Пузырьковая сортировка в коде Python

Пусть data — массив для сортировки. Индекс последнего элемента массива будет равен len(data) - 1.
При первом проходе потребуется сравнить попарно все элементы массива, включая и последний. На втором проходе надо сравнить все элементы, кроме последнего, на третьем — исключив из сравнения два последних. 

На каждом проходе сравниваем всё меньше элементов, последовательно исключая из проверок элементы в конце массива. С каждым проходом правая граница — предел, до которого проводятся сравнения элементов, — будет сдвигаться влево.

Обозначим правую границу как last_index, в ней будет храниться индекс последнего элемента, который участвует в очередном проходе. На первом проходе значение last_index будет равно индексу последнего элемента: len(data) - 1. После каждого прохода значение last_index будет уменьшаться на единицу.

Переменной item_index обозначим индекс элемента, значение которого в текущий момент сравнивается со значением следующего (item_index + 1) элемента в массиве. Сравнение элементов начинается с первого элемента в массиве, значит, в начале сортировки item_index = 0.

Создадим булеву переменную, «флаг» swapped, она будет указывать, менялись ли местами элементы при текущем проходе по массиву: перед проходом устанавливаем swapped = False, а при первом же изменении порядка элементов меняем значение переменной на True.
Приступаем к первому проходу по массиву:
1. Устанавливаем значение флага swapped = False: проход по массиву ещё не начался, перестановок не было.
2. Сравниваем элементы с индексами item_index и item_index + 1.
3. Если элемент с индексом item_index больше, чем следующий за ним элемент с индексом item_index + 1: 
 3.1. Меняем местами эти элементы массива: 
 data[item_index], data[item_index + 1] = data[item_index + 1], data[item_index].
 3.2. Значение флага swapped меняем на True: отмечаем, что совершена перестановка.
4. Добавляем к item_index единицу и переходим к сравнению следующей пары элементов (выполняем п. 2).
5. После того как проверка дошла до предпоследнего элемента в текущем проходе (с индексом last_index - 1) и два последних элемента сверены, проверяем флаг swapped: были ли перестановки в этом проходе.
 5.1. Если swapped is True, уменьшаем last_index на единицу и возвращаемся к первому шагу. 
 5.2. Если swapped is False, массив отсортирован, завершаем работу.
В коде потребуется создать два цикла:
Во внутреннем цикле переменной item_index будут присваиваться индексы от 0 до last_index, элементы будут попарно сравниваться и при необходимости меняться местами.

Каждый раз, когда внутренний цикл выполнится до конца, внешний цикл будет уменьшать last_index на единицу и вновь запускать внутренний цикл. 
Внешний цикл должен выполняться до тех пор, пока будет возвращаться swapped is True или пока last_index не станет равен 1.

Внешний цикл можно реализовать двумя способами:
1. Можно написать внешний цикл через for. Если массив окажется отсортирован до того, как будут перебраны все элементы, из цикла можно выйти при помощи ключевого слова break.
2. Можно написать внешний цикл через while. Условием выхода из цикла будет swapped is False.

У одного алгоритма может быть несколько реализаций. Принципиально от этого алгоритм не меняется.

Проверьте свои силы — самостоятельно напишите алгоритм пузырьковой сортировки, опираясь на описание и подсказки. Варианты решения разберём чуть ниже.

Напишите два вложенных цикла. В одном уменьшайте значение last_index от len(data) - 1 до единицы включительно, во втором увеличивайте значение item_index от нуля до last_index - 1 включительно.

Во внутреннем цикле сравнивайте элементы с индексами item_index и item_index + 1. Если элемент data[item_index] больше, чем data[item_index + 1], меняйте их местами через обмен значениями.

Если же вы реализуете внешний цикл через while swapped:, то перед его стартом необходимо задать значение last_index = len(data) - 1 и установить флаг swapped = True, чтобы цикл выполнился хотя бы один раз.
'''






example_array = [6, 5, 3, 1, 8, 7, 2, 4]


def bubble_sort(data):
    # Устанавливаем значение last_index равным индексу последнего элемента.
    last_index = len(data) - 1
    # Чтобы цикл while мог стартовать, устанавливаем флаг в значение True.
    swapped = True
    # Цикл будет выполняться, если флаг swapped = True. Это значение
    # устанавливается при первом проходе и в случае, если на предыдущем проходе
    # были перестановки. Если перестановок не было, то цикл перестанет выполняться.
    while swapped:
        # Для текущего прохода сбрасываем значение флага на False.
        swapped = False
        # Внутренний цикл - такой же, как и в предыдущем листинге.
        # Формируем внутренний цикл от 0 до last_index (исключая last_index).
        for item_index in range(last_index):
            # Сравниваем значения элементов списка.
            if data[item_index] > data [item_index + 1]:
                # Если значения надо поменять местами - меняем.
                data[item_index], data[item_index + 1] = data[item_index + 1], data[item_index]
                # Выставляем флаг "выполнена перестановка".
                swapped = True
        # Уменьшаем значение last_index на единицу.
        last_index -= 1
    # Возвращаем отсортированный список.
    return data


print(bubble_sort(example_array)) 



# sys.stdin.readline()