# Наследование

Допустим есть класс общий транспорт. Он имеет методы `start()`, `stop()` а также атрибуты мощьность, цвет

```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
    
    def start(self):
        print("Транспорт запущен")

    def stop(self):
        print("Транспорт остановлен")
```
На основе уже имеющегося класса можно создовать новые (дочерние классы). В данном случае класс Tranport (станет родительским классом). Дочерние классы наследуют от родительского все атрибуты и методы.

```bash
# Дочерний класс
class Ground(Transport):
    pass


bmv = Ground(100)
print(bmw.power)
# 100
print(bmw.color)
# red
```

Класс Ground унаследовал все атрибуты и методы родительского класса Transport.

# Переопределение атрибутов и методов
Можно переопределять атрибуты и методы которые унаследовал дочерний класс. Для этого при описании дочернего класса нужно объявить атрибут или метод с таким же именем, как в родительском классе, и описать его по-новому.

```bash 
class Ground(Transport):
    def __init__(self. power):
        self.power = power

bmw = Ground(100, "зеленый")
print(bmw.power)
# 100
print(bmw.color)
# зеленый
```

Также для создания атрибутов понадобится инициализатор класса. В дочернем классе его не нужно описывать с нуля — можно задействовать родительский инициализатор.
```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
    
    def start(self):
        print("Транспорт запущен")

    def stop(self):
        print("Транспорт остановлен")


class Ground(Transport):
    def __init__(self, power, color, number_of_doors):
        self.number_of_doors = number_of_doors
        super().__init__(power, color)

```
У объектов дочерних классов есть доступ к атрибутам и методам родительского класса, а вот объекты родительского класса не могут воспользоваться возможностями дочернего.


# Полиморфизм
У нас есть два класса. В базовом классе и дочернем есть метод с одинаковым названием. Но работает он по разному.
Имя ему — полиморфизм «многоформенность». В нашем контексте это значит как раз таки то, что метод с именем из базового класса может воплощаться по-разному
```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
    
    def start(self):
        print("Транспорт запущен")

    def stop(self):
        print("Транспорт остановлен")


class Ground(Transport):
    def __init__(self, power, color, number_of_doors):
        self.number_of_doors = number_of_doors
        super().__init__(power, color)

    def start(self):
        print('Транспорт начал движение')

transp = Transport(100)
bmw = Ground(150, 'black', 4)

transp.start()
bmw.start()

print(dir(bmw)) # выводим список всех методов и атрибутов объекта bmw


```

У каждого класса в Python есть свой метод __str__. Для всех классов, встроенных и пользовательских, значение этого метода по умолчанию определено в базовом классе object. 

Но когда вы вызываете его для встроенных классов, вы получаете разный результат:
```bash
# Целые числа (int):
  value = 42
  print(value)
  
  # Выведется: 
  # 42
   
# Строки (str):
  string = 'Hello, World!'
  print(string)
  
  # Выведется: 
  # Hello, World!
   
# Списки (list):
  my_list = [1, 2, 3, 4, 5]
  print(my_list)

  # Выведется: 
  # [1, 2, 3, 4, 5]

```

Метод __str__ по умолчанию переопределён для встроенных классов.

Если метод __str__ не переопределить для пользовательского класса, результат его работы будет таким, каким он определён в классе object.

Пример:
```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
    
    def start(self):
        print("Транспорт запущен")

    def stop(self):
        print("Транспорт остановлен")


class Ground(Transport):
    def __init__(self, power, color, number_of_doors):
        self.number_of_doors = number_of_doors
        super().__init__(power, color)

    def start(self):
        print('Транспорт начал движение')

transp = Transport(100)
bmw = Ground(150, 'black', 4)

print(transp)
print(bmw)
# Вывод
# <__main__.Transport object at 0x000001F325173E50>
# <__main__.Ground object at 0x000001F325173DF0>

```

Теперь применим метод __str__

```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
    
    def start(self):
        print("Транспорт запущен")

    def stop(self):
        print("Транспорт остановлен")

    def __str__(self):
        return f'Транспорт со скорость {self.power} км/ч'


class Ground(Transport):
    def __init__(self, power, color, number_of_doors):
        self.number_of_doors = number_of_doors
        super().__init__(power, color)

    def start(self):
        print('Транспорт начал движение')


    def __str__(self):
        return f'Машина {self.color} цвета'

transp = Transport(100)
bmw = Ground(150, 'black', 4)

print(transp)
print(bmw)

```
Метод один и тот же, но в каждом классе он работает по-разному.

У всех объектов в Python есть метод __str__, а у всех объектов класса Ground есть методы и атрибуты класса Transport.

Можно создать любое количество экземпляров любых классов, и у каждого из них будут атрибуты и методы родительского класса. Значения атрибутов и возможности методов могут отличаться, но сами атрибуты и методы остаются.

В примерах выше вы выводили на печать абсолютно разные объекты, результат для каждого из них был свой, однако достигался он всегда одинаково — при помощи метода __str__.


# Инкапсуляция
В Python все атрибуты и методы класса по умолчанию публичные. Это значит, что к ним без ограничений можно обращаться как из класса, так и из любой части программы.

Но бывают такие методы и атрибуты, к которым доступ вне класса не нужен или нежелателен. Разработчики могут предупреждать друг друга о подобных методах или атрибутах, делая их защищёнными или приватными.

# Защищённые атрибуты и методы
Если нужно показать, что атрибут или метод должен использоваться только для внутренних нужд класса или его наследников, перед названием атрибута или метода добавляют одинарное подчёркивание _. Такой атрибут или метод будет считаться защищённым.

Например вин номер траспорта может быть защищённым:
```bash
class Transport:
    def __init__(self, power, color='red'):
        self.power = power
        self.color = color
        self._vin = 'ABCD1234'
```
Увидев такой атрибут в коде, разработчик будет понимать, что желательно использовать его только внутри класса или его наследников. Хотя ничто не помешает разработчику обратиться к этому атрибуту не только через метод, но и напрямую из любой части программы.

Одинарное подчёркивание перед атрибутом — это предупреждение для других разработчиков: «Обрати внимание, этот атрибут или метод используется только для внутренних нужд класса и его наследников, но если он тебе действительно нужен — к нему доступ есть».

# Приватные атрибуты и методы
Для Python атрибут или метод, имя которого начинается с двойного подчёркивания __, — приватный. К этому атрибуту можно обратиться внутри класса, а вот вне класса просто так сделать это не получится.

```bash
class Ground(Transport):
    def __init__(self, power, color, number_of_doors, name):
        self.number_of_doors = number_of_doors
        self.__name = name
        super().__init__(power, color)

    def start(self):
        print('Транспорт начал движение')


    def __str__(self):
        return f'Машина {self.color} цвета'

bmw = Ground(150, 'black', 4, 'Иванов И.И.')

print(bmw.__name)
# Выдаст:
# AttributeError: 'Ground' object has no attribute '__name'
```

В Python приватные атрибуты и методы наследуются дочерними классами. Однако из-за механизма именования, известного как name mangling («искажение имён»), доступ к ним становится менее прямолинейным.

Когда вы определяете атрибут или метод, имя которого начинается с двойного подчёркивания, Python автоматически изменяет его имя, добавляя к нему _ИмяКласса. Например, если у вас есть класс Ground  с приватным атрибутом __name, Python преобразует его имя в _Ground__name. Это делается для того, чтобы минимизировать конфликты имён при наследовании.

Из-за этого механизма приватные атрибуты и методы становятся менее доступными вне  класса и из подклассов, но всё же доступ к ним возможен, если вы знаете исходное имя класса и используете изменённое имя атрибута или метода.

В Python все уровни доступа к атрибутам и методам — это соглашение, а не строгое ограничение. Соглашение можно не соблюдать, однако это считается плохой практикой, так как нарушает принципы инкапсуляции.