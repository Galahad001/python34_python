# Итерация и итерируемый обьект, итератор

Итерируемым называют объект, который содержит элементы, и эти элементы можно перебрать. Каждый шаг перебора — это итерация.

В Python итерируемые объекты — это, например, списки, кортежи, строки.

Чтобы проверить, итерируется объект или нет, можно применить к нему функцию iter(). Для итерируемых объектов она вернёт объект итератора, а для неитерируемых — ошибку object is not iterable.

```bash
english_words = ['apple', 'banana', 'cherry', 'date', 'fig']
# Объект english_words итерируемый?
print(iter(english_words))

quantity = 5
# Объект quantity итерируемый?
print(iter(quantity))
```

Любой итерируемый объект содержит метод __iter__():
```bash
english_words = ['apple', 'banana', 'cherry', 'date', 'fig']
# У объекта english_words есть метод __iter__?
print('__iter__' in dir(english_words))
```

И у любого объекта итератора есть метод __next__(), который обеспечивает обращение к следующему элементу итерируемого объекта:
```bash
english_words = ['apple', 'banana', 'cherry', 'date', 'fig']
# "Положить" в переменную 'a' объект итератора.
a = iter(english_words)
# У объекта итератора, который "лежит" в переменной 'а',
# есть метод '__next__'?
print('__next__' in dir(a))
# Обратиться к одному элементу итерируемого объекта...
print(a.__next__())
# Обратиться к следующему элементу итерируемого объекта.
print(a.__next__())
```

Когда в итераторе заканчиваются элементы для перебора, нужно выбрасывать исключение StopIteration
```bash
class MyRange:
    def __init__(self, start, end):
        # Установить начальное значение последовательности. 
        self.current = start
        # Установить конечное значение последовательности.
        self.end = end
    
    # Метод, который возвращает сам объект (self) в качестве итератора.
    def __iter__(self):
        return self
    
    # Метод, который реализует логику получения следующего 
    # элемента последовательности.
    def __next__(self):
        # Если начальное значение последовательности меньше или равно 
        # конечному значению...
        if self.current <= self.end:
            # ...вернуть текущее значение...
            value = self.current
            # ...и увеличить его на 1.
            self.current += 1
            return value
        # Иначе...
        else:
            # выбросить исключение StopIteration, чтобы указать, 
            # что элементы в последовательности закончились.
            raise StopIteration


# Тут используется описанный в классе итератор: 
# создать объект класса MyRange с начальным значением 1 
# и конечным значением 5.
my_iterator = MyRange(1, 5)

# Здесь происходит итерация по объекту my_iterator:
# к каждой итерации получить значение с помощью метода __next__ 
# и это значение присвоить переменной num.
for num in my_iterator:
    print(num)
```

# Что такое генератор
Генератор — это подвид итератора: функция, которая генерирует значения.

Генератор не хранит элементы в оперативной памяти, а вычисляет их по заданному правилу. Как следствие, генератор занимает в памяти очень мало места.

Генератор объявляется как обычная функция, но вместо инструкции return в нём используется yield. Инструкция return завершает работу функции, а yield лишь приостанавливает её и при этом возвращает какое-то значение.

Изучите код, прочтите комментарии и запустите программу:
```bash
# Создать функцию-генератор.
def short_sequence():
    num = 1
    while num < 5:
    # Сгенерировать значение через yield.
        yield num
        num += 1

# Здесь функция-генератор возвращает итератор.
step = short_sequence()

# Обратиться к методу __next__() итератора
# и получить первое значение последовательности.
print(step.__next__())

# Ещё раз обратиться к методу __next__()
# и получить второе значение последовательности.
print(step.__next__())
```

Логика работы кода такова:

При первом вызове метода __next__() инструкция yield генерирует и возвращает первое значение — 1.

Затем функция-генератор встаёт на паузу на выполнении цикла while, запомнив своё состояние.

При втором вызове метода __next__() функция-генератор продолжает работу с того места, на котором остановилась, и возвращает следующее значение — 2.

Когда значения исчерпаются, генератор выбросит исключение StopIteration.

```bash
def short_sequence():
    num = 1
    while num < 5:
        yield num
        num += 1

for step in short_sequence():
    print(step)
```

```bash
def english_word_generator():
    # Сгенерировать слово.
    yield 'orange'
    
    # Проитерироваться по списку слов и вернуть каждое слово из списка.
    for word in ['apple', 'banana', 'Cherry', 'Date', 'fig']:
        yield word

    # Сгенерировать ещё одно слово.
    yield 'pineapple'

# Запустить генератор, проитерироваться по всем возвращаемым им значениям 
# и вывести каждое значение на экран.
for word in english_word_generator():
    print(word)
```

# Что такое генераторное выражение
Генераторное выражение — это упрощённый синтаксис для создания генератора.

Очень часто генераторы могут быть записаны с использованием синтаксиса, похожего на list comprehension, но не в квадратных, а в круглых скобках.
```bash
simple_generator = (digit for digit in range(2))

print(type(simple_generator))
print(simple_generator.__next__())
print(simple_generator.__next__())

# Выведется:
# <class 'generator'>
# 0
# 1
```
Генераторы требуют меньше памяти, и если нужно сформировать последовательность, то выгоднее формировать её именно через генератор или генераторное выражение, а не через list comprehension.


# В чём разница между итератором и генератором
Все генераторы — итераторы, но не все итераторы — генераторы. Итератор — более общая концепция.

Генератор хранит в памяти не элементы, а внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. 

Генератор, исчерпавший все свои значения, помнит своё состояние («я всё сделал!»), поэтому повторное обращение к нему не вернёт никакого результата. Второй раз подряд проитерироваться по генератору не получится.
```bash
def calc_squares(start, stop):
    for i in range(start, stop):
        yield i * i

generator = calc_squares(5, 10)

# Первый перебор.
print(list(generator))
# Второй перебор. 
print(list(generator))
```